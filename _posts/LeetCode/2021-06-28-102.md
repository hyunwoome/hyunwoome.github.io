---
title: 102. Binary Tree Level Order Traversal
categories: [LeetCode]
comments: true
---

[문제](https://leetcode.com/problems/binary-tree-level-order-traversal/)

## 문제 설명

이진 트리의 `root`가 주어지면, 노드 값의 레벨 순서 순회(level-order traversal)를 반환한다. (왼쪽에서 오른쪽으로, 레벨별로)

**예시 1**

```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
```

**예시 2**

```
Input: root = [1]
Output: [[1]]
```

**예시 3**

```
Input: root = []
Output: []
```

**제한사항**

- 트리의 노드 수는 [0, 2000]범위안에 있다.
- -1000 <= Node.val <= 1000

<br>

## 해결방법

**접근하기**

이진 트리를 탐색하기 위한 방법은 대표적으로 두 가지가 있다.

첫 번째는 `DFS(Depth-First Search)`로 깊이 우선 탐색이라고 한다. 전에 작성했던 트리를 순회하는 방법인 전위, 중위, 후위 순회는 이 DFS의 종류라고 할 수 있다. 이름처럼 트리의 깊은곳을 먼저 탐색하는 방식이라고 보면 된다.

두 번째는 `BFS(Breadth-First Search)`로 너비 우선 탐색이라고 한다. 이 알고리즘은 루트 노드를 먼저 방문하고 하위 노드의 이웃들을 먼저 방문하면서 내려가는 방법이다. `DFS`는 보통 재귀와 스택 자료구조를 이용해서 구현하지만 `BFS`는 큐 자료구조를 이용한다.

**알고리즘**

1. `BFS`는 자료구조 큐를 이용해서 구현하는 알고리즘이라고 했다. 큐에 넣을 때 값이 반환되는 것이 아닌, **큐에서 나올 때 값이 반환된다는 점을 알아야 한다.**
2. 아래 풀이 코드의 3번째 줄을 보면 `queue` 변수에 `root`를 담는 모습이다. `root`는 `root`의 첫 번째 값이 들어가 있으며, `left`와 `right`로 참조한다.
3. `while`문 내부의 `for`문을 살펴보자. `while`문은 큐가 빌 때까지 반복하며, `for`문에선 현재 `queue`에 들어있는 노드를 `shift`해서 빼고, 이 문제는 2중배열로 반환해야 하므로 내부의 `currLevel`에 담게 된다.
4. 그 전에 `current`에 왼쪽, 오른쪽을 참조하여 다음 레벨을 탐색할 수 있도록 했다. 만약 `root`가 이진 트리의 `[1, 2, 3]`이라면, 처음 큐에 1이 들어가고 for문에서 1을 꺼내고 배열에 담는다. 그리고 반환 직전, 두 if문으로 인해 1의 연결된 왼쪽과 오른쪽 (2와 3)을 다시 큐에 담고, for문으로 인해 순회하면서 다시 큐에서 제거 후 배열에 담고.. 이런식으로 반복되면서 레벨 단위로 순회가 가능한 것이다.

<br>

## 풀이코드

```js
// Queue

var levelOrder = function (root) {
  if (!root) return [];

  const queue = [root];
  const answer = [];

  while (queue.length !== 0) {
    const queueLength = queue.length;
    const currLevel = [];
    for (let i = 0; i < queueLength; i++) {
      const current = queue.shift();
      if (current.left) queue.push(current.left);
      if (current.right) queue.push(current.right);
      currLevel.push(current.val);
    }
    answer.push(currLevel);
  }
  return answer;
};
```

**복잡도**

- 시간 복잡도: `O(N)`이며, `N`은 이진 트리의 노드 수를 의미한다.
