---
title: LeetCode - 27. Remove Element
categories: [PS]
comments: true
---

[문제](https://leetcode.com/problems/remove-element/)

## 문제 설명

정수형 배열 `nums`와 정수 `val`이 주어지며, 제자리 방식(**in-place**)으로 `nums` 배열에 있는 `val`을 제거해야 한다. 원소들의 상대적인 순서는 변경될 수 있다.

몇몇 언어에선 배열의 길이를 바꾸는 것이 불가능하기 때문에, 원소를 제거한 후 남아있는 배열의 개수 `k`를 반환한다.

`nums`의 처음 `k`슬롯에 최종 결과를 배치한 후 `k`를 반환한다.

다른 배열을 사용해추가적인 공간을 할당하지 않는다. 반드시 `O(1)`의 추가 메모리를 사용하여 입력 배열에서 제자리(in-place) 수정하여 이를 수행해야 한다.

**예시 1**

```
입력: nums = [3, 2, 2, 3], val = 3
출력: 2, nums = [2, 2, _, _]
설명: nums에 두 요소가 남았으므로 k = 2를 반환해야 한다. 반환된 k 이상으로 남겨두는 것은 상관없다. (따라서 밑줄로 표현한다)
```

**예시 2**

```
입력: nums = [0,1,2,2,3,0,4,2], val = 2
출력: 5, nums = [0,1,4,0,3,_,_,_]
설명: nums에 다섯개의 요소가 남았으므로 k = 5를 반환해야 한다.
```

**제한사항**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

<br>

## 해결방법

**접근하기**

**또 다른 배열을 만들지 않고서** `nums`에 `val`과 동일한 원소를 제거하고 **나머지 원소의 갯수를 반환**해야 한다. 그럼 두 가지 방법을 사용할 수 있을 것 같다.

첫 번째는 **투포인터**를 이용한 방식이다. 포인터 `i`는 0부터 시작하고, 포인터 `j`는 맨 뒤부터 시작해서 탐색하는 방식이다.

두 번째 방법은 자바스크립트는 배열을 직접 조작할 수 있으므로 제거해야할 값`val`과 같은 값을 실제로 배열에서 제거하는 방식이다. 이 방식이 좀더 직관적이라 이해하기 쉽다.

**알고리즘**

1. 먼저 투포인터 방식을 이용해 제거 후 남아있는 원소들의 갯수를 파악해보자.
2. 포인터 `i`는 증가시키고, 포인터 `j`는 감소시키면서 결국 만나게 되면 모든 배열의 탐색을 마치게 되는 것이다.
3. `nums[i]`가 제거해야할 값 `val`과 같다면, 뒤에서 오는 `nums[j]`와 스왑을 해주고 포인터 `j`를 감소시켜 위에서부터 아래로 제거해야할 값으로 채울 수 있게 한다.
4. 만약 `nums[i]`가 제거해야할 값 `val`이 같지 않다면, `i`가 가리키는 값이 `val`이 아니므로 다음 탐색을 위해 `i`를 증가시킨다.
5. 탐색이 끝나면 `j`가 가리키는 인덱스 번호가 `배열의 모든 요소 갯수 - 제거해야할 요소 갯수`가 되므로 `j`를 반환한다.

---

1. 다음으로 배열을 직접 삭제하는 방식이다.
2. 배열 `nums`를 순회하면서 제거해야할 값과 일치하다면, 해당 인덱스를 제거하는 방식이다. 자바스크립트에는 `Array.splice()`라는 메서드가 있으며, 이 메서드는 배열의 **원소를 추가하거나 삭제할 때 쓰이며** 굉장히 자주 쓰이는 메서드이다.
3. `for`문에서 `splice()`를 사용할 때 주의해야할 점이 있다. `splice()`는 해당 인덱스를 제거할 수 있는 기능이 있는데, 만약 제거하게 되면 빈 공간에 원소들이 하나씩 밀리게 된다. 그래서 `i`가 제거된 인덱스 다음 인덱스가 빈 **공간을 차지하기 위해 내려오게 되어 한 칸을 건너뛰어버린다.** 이 것을 방지하기 위해 제거했을 땐 `i`의 값을 감소시켜줌으로써 뛰어넘는 걸 방지할 수 있다.

<br>

## 풀이코드

```js
// Two Pointer

var removeElement = function (nums, val) {
  let i = 0;
  let j = nums.length;

  while (i < j) {
    if (nums[i] === val) {
      nums[i] = nums[j - 1];
      j--;
    } else {
      i++;
    }
  }
  return j;
};
```

```js
// Delete Elements

const removeElement = (nums, val) => {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === val) {
      nums.splice(i, 1);
      // for문에서 배열을 제거할 땐 i 인덱스를 꼭 감소시켜주어야 한다!!
      i--;
    }
  }
  return nums.length;
};
```

**복잡도**

- 시간복잡도: 배열의 모든 원소를 한 번씩 순회하므로 **O(n)**을 만족한다.
