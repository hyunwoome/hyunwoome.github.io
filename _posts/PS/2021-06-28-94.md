---
title: LeetCode - 94. Binary Tree Inorder Traversal
categories: [PS]
comments: true
---

[문제](https://leetcode.com/problems/binary-tree-inorder-traversal/)

## 문제 설명

이진 트리의 `root`가 주어지면, 노드의 값들을 중위 순회로 반환하라.

**예시 1**

```
Input: root = [1,null,2,3]
Output: [1,3,2]
```

**예시 2**

```
Input: root = []
Output: []
```

**예시 3**

```
Input: root = [1]
Output: [1]
```

**예시 4**

```
Input: root = [1,2]
Output: [2,1]
```

**예시 5**

```
Input: root = [1,null,2]
Output: [1,2]
```

**제한사항**

- 트리의 노드 수는 [0, 100]범위안에 있다.
- 100 <= Node.val <= 100

<br>

## 해결방법

**접근하기**

이진 트리의 중위 순회를 하기 위해선 대표적으로 재귀 호출하는 방법과 스택을 이용한 반복이 있다. 두 방법을 이용해서 구현해보자.

**알고리즘**

1. 첫 번째 방법은 재귀를 이용한 방법이다.
2. `inorderTraversal(root)`함수 내부로 들어가보자. 결과를 담는 `result`배열과 `traverse(node)`라는 순회를 위한 중첩함수를 호출하고 있다.
3. `traverse(node)`가 순회하기 위한 핵심로직이며, 재귀를 이루는 부분이다. 먼저 처음 `traverse(root)`를 호출하면 `traverse(1)`로 호출이 되며, 저 `1`은 일반적인 숫자가 아닌, LeetCode에서 미리 정의된 생성자 함수 `TreeNode`의 객체이다. 즉, `1`은 프로퍼티로 `val`, `left`, `right`를 가지고 있다.
4. `traverse(root)`를 호출하게 되면, `traverse()`함수 내부로 들어가게 된다. 여기서 결과에 푸쉬하는 코드가 어디에 위치하는지 순서가 중요하다.
5. 중위 순회는 루트가 중앙에 위치하게 된다. 즉, 왼쪽 - **루트** - 오른쪽 순서를 기억하자.
6. `traverse(node.left)`로 먼저 왼쪽 노드가 `null`일 때 까지 호출한다.
7. 더이상 왼쪽 노드가 없어 `null`을 만나게 되면 스택프레임에 쌓여있던 왼쪽 노드들이 호출이 되며 `result`에 `push`가 된다.
8. 왼쪽 노드의 `push`가 끝나면 이제 `root`를 `push`하게 되고 다음 오른쪽 노드를 탐색하게 되서 위 절차와 동일한 방법으로 순회하게 된다. 결국, 루트가 중앙으로 오게 되는 중위 순회가 이루어진다.

---

1. 다음은 스택방식이다. 스택도 재귀와 매우 유사하다.
2. `while`문 내부의 `while`문을 보면, `curr`은 `root`를 가리키며, 최초 스택에 1을 넣는다. 다음 `left`를 먼저 방문하며 `null`이 나올 때 까지 반복하고, `null`이 나오면 스택에서 `pop()`한 후 해당 값을 `result`에 담는다.
3. 그 다음 `root`를 결과에 담고 이제 오른쪽을 순회한다.

<br>

## 풀이코드

```js
// Recursive

const inorderTraversal = (root) => {
  const result = [];
  traverse(root);
  return result;

  function traverse(node) {
    if (!node) return;
    traverse(node.left);
    result.push(node.val);
    traverse(node.right);
  }
};
```

```js
// Stack

const inorderTraversal = (root) => {
  let curr = root;
  let result = [];
  let stack = [];
  while (curr || stack.length) {
    while (curr) {
      stack.push(curr);
      curr = curr.left;
    }
    curr = stack.pop();
    result.push(curr.val);
    curr = curr.right;
  }
  return result;
};
```

**복잡도**

- 시간 복잡도: 재귀와 스택 둘 다 배열을 한 번만 순회하므로 `O(N)`을 갖는다.
