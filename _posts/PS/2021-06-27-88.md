---
title: LeetCode - 88. Merge Sorted Array
categories: [PS]
comments: true
---

[문제](https://leetcode.com/explore/learn/card/fun-with-arrays/525/inserting-items-into-an-array/3253/)

## 문제 설명

두 정수 배열 `nums1`과 `nums2`가 주어지며, 이는 **오름차순**으로 정렬되어 있고, 두 정수 `m`과 `n`은 `nums1`과 `nums2`에 각각 원소의 개수를 표현한다.

`nums1`과 `nums2`를 단일 배열 **오름차순**정렬로 **병합**하라.

최종 정렬된 배열은 함수에 의해 반환되지 않아야 하며, 대신 배열 `nums1`내에 **병합**되어야 한다. 이를 충족시키기 위해 `nums1`의 길이는 `m + n`을 가지며, 여기서 처음 `m`개의 원소는 병합되어야 하는 요소를 나타내며, 마지막 `n`의 원소는 0으로 설정되며 무시해야 한다. `nums2`는 `n`의 길이를 갖는다.

**예시 1**

```
입력: nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3
출력: [1, 2, 2, 3, 5, 6]
설명: 병합하려는 배열은 [1, 2, 3]과 [2, 5, 6]이다.
병합의 결과는 [1, 2, 2, 3, 5, 6]이며, 1, 2, 3이 nums1로부터 들어온 원소이다.
```

**예시 2**

```
입력: nums1 = [1], m = 1, nums2 = [], n = 0
출력: [1]
설명: 병합하려는 배열은 [1]과 []이다.
병합의 결과는 [1]이다.
```

**예시 3**

```
입력: nums1 = [0], m = 0, nums2 = [1], n = 1
출력: [1]
설명: 병합하려는 배열은 []과 [1]이다.
병합의 결과는 [1]이다.
m = 0이므로 nums1에는 요소가 없다. 0은 병합 결과가 nums1에 들어갈 수 있도록 하기 위해서만 존재한다.
```

**제한사항**

- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `1 <= m + n <= 200`
- `-109 <= nums1[i], nums2[j] <= 109`

<br>

## 해결방법

**접근하기**

이 문제의 의도에 맞게 새 배열을 만들어 삽입하지 않고 기존 배열에 대해 병합해야 한다. 그렇다면 두 배열의 원소들을 **비교**해가며, `nums2`의 원소들을 `nums1`에 오름차순 순서에 맞게 넣어야 한다.

<img width="783" alt="Screen Shot 2021-06-27 at 12 55 17 PM" src="https://user-images.githubusercontent.com/76833697/123532314-192d9680-d747-11eb-8906-3225083b0469.png">

**알고리즘**

1. 배열의 원소를 비교하기 위한 기법으로 **투 포인터 알고리즘**을 사용한다. 투 포인터 알고리즘은 **1차원 배열이 있고 이 배열에서 각자 다른 원소를 가리키고 있는 2개의 포인터를 조작해가며 원하는 것을 얻는 알고리즘**이다.
   위 그림에서 `i`와 `j`가 포인터가 된다.
2. `nums1`에 오름차순으로 정렬해야 하므로 `nums1[i]`와 `nums2[j]`를 비교해 `nums1`에 삽입한다. 아래 풀이코드에선, `nums1[i]`가 `nums2[j]`보다 클 때, `nums1[i]`의 앞에 위치하도록 작성되었다. 그러면 오름차순이 될 것이다. 이 조건이 성립되면 다음 인덱스를 비교하기 위해 `i`와 `j`의 인덱스 값을 증가시킨다.
3. 이 조건이 성립되지 않는다면, `nums[j]`의 값이 더 크다는 의미이므로 `i`가 가리키는 인덱스를 증가시켜 `nums[i]`의 값을 높은 값으로 변경한다.
4. 이러한 단계는 `nums1`에 병합하려는 배열, 즉 `nums2`를 다 순회할 때 까지 진행한다.

<br>

## 풀이코드

```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} 아무것도 반환하지 말아야 하며, 대신 제자리 방법(in-place)으로 nums1을 수정하라.
 */
var merge = function (nums1, m, nums2, n) {
  // nums1 뒤에있는 0을 제거
  nums1.splice(m, nums1.length - m);

  // 두 포인터 정의
  var i = 0;
  var j = 0;

  // j는 nums2를 끝까지 순회할 때 까지 다음 조건을 반복한다.
  while (j < nums2.length) {
    // nums1[i]가 0을 제거했으므로 undefined이 되거나,
    // nums1[i] > nums2[j]라면, nums1의 해당 인덱스에 nums2[j]를 삽입
    if (nums1[i] === undefined || nums1[i] > nums2[j]) {
      nums1.splice(i, 0, nums2[j]);
      j++;
      i++;
      // 아니라면 nums2[j]가 nums1[i]보다 크기 때문에 nums1[i]도 수를 증가시키기 위해 i만 증가시킨다.
    } else {
      i++;
    }
  }
};
```

**복잡도**

- 시간 복잡도: `nums1`과 `nums2` 원소의 갯수만 순회하면 되기 때문에 **O(m + n)**을 만족할 것이다.
