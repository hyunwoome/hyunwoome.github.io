I"("<p><a href="https://programmers.co.kr/learn/courses/30/lessons/49993">문제</a></p>

<h2 id="문제-설명">문제 설명</h2>

<p>문자열 <code class="language-plaintext highlighter-rouge">skill</code>과 문자열 배열 <code class="language-plaintext highlighter-rouge">skill_trees</code>가 주어진다.
문제는 꽤 길지만, 결국 묻고자 하는 것은, <code class="language-plaintext highlighter-rouge">skill</code>의 문자열 순서와 일치하는 <code class="language-plaintext highlighter-rouge">skill_trees</code>의 문자열을 찾아 그 갯수를 반환하는 문제이다.
예를 들어, <code class="language-plaintext highlighter-rouge">skill</code>이 <code class="language-plaintext highlighter-rouge">CBD</code>라고 한다면, <code class="language-plaintext highlighter-rouge">D</code>가 올려면 반드시 <code class="language-plaintext highlighter-rouge">B</code>가 앞에 있어야 하고, <code class="language-plaintext highlighter-rouge">B</code>가 오려면 반드시 <code class="language-plaintext highlighter-rouge">C</code>가 있어야 한다. 이 순서만 지킨다면 가운데 어떠한 문자가 들어와도 상관없다.</p>

<p><strong>예시 1</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>skill: "CBD"
skill_trees: ["BACDE", "CBADF", "AECB", "BDA"]
return: 2
- "BACDE": B가 오기전에 C가 먼저 와야하므로 잘못된 문자열이다.
- "CBADF": 가능하다.
- "AECB": 가능하다.
- "BDA": B가 오기전에 C가 먼저 와야하므로 잘못된 문자열이다.
</code></pre></div></div>

<p><strong>제한사항</strong></p>

<ul>
  <li>트리의 노드 수는 [0, 2000]범위안에 있다.</li>
  <li>-1000 &lt;= Node.val &lt;= 1000</li>
</ul>

<p><br /></p>

<h2 id="해결방법">해결방법</h2>

<p><strong>접근하기</strong></p>

<p>이진 트리를 탐색하기 위한 방법은 대표적으로 두 가지가 있다.</p>

<p>첫 번째는 <code class="language-plaintext highlighter-rouge">DFS(Depth-First Search)</code>로 깊이 우선 탐색이라고 한다. 전에 작성했던 트리를 순회하는 방법인 전위, 중위, 후위 순회는 이 DFS의 종류라고 할 수 있다. 이름처럼 트리의 깊은곳을 먼저 탐색하는 방식이라고 보면 된다.</p>

<p>두 번째는 <code class="language-plaintext highlighter-rouge">BFS(Breadth-First Search)</code>로 너비 우선 탐색이라고 한다. 이 알고리즘은 루트 노드를 먼저 방문하고 하위 노드의 이웃들을 먼저 방문하면서 내려가는 방법이다. <code class="language-plaintext highlighter-rouge">DFS</code>는 보통 재귀와 스택 자료구조를 이용해서 구현하지만 <code class="language-plaintext highlighter-rouge">BFS</code>는 큐 자료구조를 이용한다.</p>

<p><strong>알고리즘</strong></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">BFS</code>는 자료구조 큐를 이용해서 구현하는 알고리즘이라고 했다. 큐에 넣을 때 값이 반환되는 것이 아닌, <strong>큐에서 나올 때 값이 반환된다는 점을 알아야 한다.</strong></li>
  <li>아래 풀이 코드의 3번째 줄을 보면 <code class="language-plaintext highlighter-rouge">queue</code> 변수에 <code class="language-plaintext highlighter-rouge">root</code>를 담는 모습이다. <code class="language-plaintext highlighter-rouge">root</code>는 <code class="language-plaintext highlighter-rouge">root</code>의 첫 번째 값이 들어가 있으며, <code class="language-plaintext highlighter-rouge">left</code>와 <code class="language-plaintext highlighter-rouge">right</code>로 참조한다.</li>
  <li><code class="language-plaintext highlighter-rouge">while</code>문 내부의 <code class="language-plaintext highlighter-rouge">for</code>문을 살펴보자. <code class="language-plaintext highlighter-rouge">while</code>문은 큐가 빌 때까지 반복하며, <code class="language-plaintext highlighter-rouge">for</code>문에선 현재 <code class="language-plaintext highlighter-rouge">queue</code>에 들어있는 노드를 <code class="language-plaintext highlighter-rouge">shift</code>해서 빼고, 이 문제는 2중배열로 반환해야 하므로 내부의 <code class="language-plaintext highlighter-rouge">currLevel</code>에 담게 된다.</li>
  <li>그 전에 <code class="language-plaintext highlighter-rouge">current</code>에 왼쪽, 오른쪽을 참조하여 다음 레벨을 탐색할 수 있도록 했다. 만약 <code class="language-plaintext highlighter-rouge">root</code>가 이진 트리의 <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code>이라면, 처음 큐에 1이 들어가고 for문에서 1을 꺼내고 배열에 담는다. 그리고 반환 직전, 두 if문으로 인해 1의 연결된 왼쪽과 오른쪽 (2와 3)을 다시 큐에 담고, for문으로 인해 순회하면서 다시 큐에서 제거 후 배열에 담고.. 이런식으로 반복되면서 레벨 단위로 순회가 가능한 것이다.</li>
</ol>

<p><br /></p>

<h2 id="풀이코드">풀이코드</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Queue</span>

<span class="kd">var</span> <span class="nx">levelOrder</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="k">return</span> <span class="p">[];</span>

  <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nx">root</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">answer</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">queueLength</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">currLevel</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">queueLength</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
      <span class="nx">currLevel</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">val</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">answer</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">currLevel</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><strong>복잡도</strong></p>

<ul>
  <li>시간 복잡도: <code class="language-plaintext highlighter-rouge">O(N)</code>이며, <code class="language-plaintext highlighter-rouge">N</code>은 이진 트리의 노드 수를 의미한다.</li>
</ul>
:ET