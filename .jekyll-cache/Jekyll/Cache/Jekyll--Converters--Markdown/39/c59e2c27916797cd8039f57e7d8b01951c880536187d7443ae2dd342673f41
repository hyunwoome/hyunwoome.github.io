I"<p><a href="https://leetcode.com/problems/rotate-array/">문제</a></p>

<h2 id="접근하기">접근하기</h2>

<p>숫자형 배열 <code class="language-plaintext highlighter-rouge">nums</code>와 숫자 <code class="language-plaintext highlighter-rouge">k</code>가 주어진다. 숫자 배열 <code class="language-plaintext highlighter-rouge">nums</code>를 <code class="language-plaintext highlighter-rouge">k</code>만큼 오른쪽으로 회전시킨다. 단, 반환하지 않고 <code class="language-plaintext highlighter-rouge">nums</code>배열을 조작하여 문제를 풀 수 있도록 한다.</p>

<p><br /></p>

<h2 id="참고-코드">참고 코드</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">rotate</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="nx">k</span> <span class="o">%=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">nums</span><span class="p">.</span><span class="nx">pop</span><span class="p">());</span>
    <span class="nx">k</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">nums</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(...</span><span class="nx">stack</span><span class="p">.</span><span class="nx">reverse</span><span class="p">());</span>
<span class="p">};</span>
</code></pre></div></div>

<ol>
  <li>스택을 이용한다.</li>
  <li><code class="language-plaintext highlighter-rouge">k</code>는 오른쪽으로 이동할 횟수이며, <code class="language-plaintext highlighter-rouge">nums.length</code>를 나눈 나머지를 할당하는 이유는, 만약 배열의 길이가 7이고, <code class="language-plaintext highlighter-rouge">k</code>가 배열의 길이를 넘어선 11이라고 치면, 11번을 이동하던, 11 % 7로 4번을 이동하던 같기 때문이다.</li>
  <li><code class="language-plaintext highlighter-rouge">while</code>문을 이용하여 <code class="language-plaintext highlighter-rouge">k</code>가 있을 동안, <code class="language-plaintext highlighter-rouge">stack</code>배열에 푸쉬할 때, <code class="language-plaintext highlighter-rouge">nums</code>의 마지막 원소를 <code class="language-plaintext highlighter-rouge">pop</code>하여 삽입한다. 그럼 마치 둥글게 회전하는 것 같이 보인다.</li>
  <li>이동을 했으면 <code class="language-plaintext highlighter-rouge">k</code>의 카운팅을 줄이고, <code class="language-plaintext highlighter-rouge">stack</code>에 있던 수를 <code class="language-plaintext highlighter-rouge">nums</code>에 다시 앞에 넣으면서, 기존 <code class="language-plaintext highlighter-rouge">stack</code>을 <code class="language-plaintext highlighter-rouge">reverse</code>하여 다시 돌려주고 삽입한다.</li>
</ol>
:ET