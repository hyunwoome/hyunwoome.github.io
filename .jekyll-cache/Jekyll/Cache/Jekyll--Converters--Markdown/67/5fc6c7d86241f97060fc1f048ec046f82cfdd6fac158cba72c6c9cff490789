I"<p><a href="https://leetcode.com/problems/lucky-numbers-in-a-matrix/">문제</a></p>

<h2 id="접근하기">접근하기</h2>

<p>문자열 <code class="language-plaintext highlighter-rouge">s</code>와 문자 <code class="language-plaintext highlighter-rouge">c</code>가 주어진다. 문자열을 순회하면서, 문자 <code class="language-plaintext highlighter-rouge">c</code>부터의 가장 짧은 거리를 배열로 반환한다.</p>

<p><br /></p>

<h2 id="참고-코드">참고 코드</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">shortestToChar</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">let</span> <span class="nx">prev</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">c</span><span class="p">)</span> <span class="nx">prev</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
    <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">prev</span> <span class="o">-</span> <span class="nx">i</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">prev</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">c</span><span class="p">)</span> <span class="nx">prev</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
    <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">prev</span> <span class="o">-</span> <span class="nx">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<ol>
  <li>해결방법은, 처음 왼쪽에서 오른쪽으로 진행하면서 문자열들이 <code class="language-plaintext highlighter-rouge">c</code>와 얼마나 떨어져 있는지 구하고, 오른쪽에서 왼쪽으로 진행하면서 문자열들이 <code class="language-plaintext highlighter-rouge">c</code>와 얼마나 떨어져있는지를 구해서, 가장 작은 거리를 반환한다.</li>
  <li>왼쪽에서 오른쪽으로 이동하면서, <code class="language-plaintext highlighter-rouge">c</code>와의 거리를 구하기 위해 for문을 사용한다. 이전 문자열을 의미하는 <code class="language-plaintext highlighter-rouge">prev</code>에 해당 인덱스인 <code class="language-plaintext highlighter-rouge">i</code>를 절대값으로 뺀 값을 <code class="language-plaintext highlighter-rouge">result[i]</code>에 할당한다. 즉, 왼쪽에서 오른쪽을 순회하면서 <code class="language-plaintext highlighter-rouge">c</code>와의 거리는 <code class="language-plaintext highlighter-rouge">[Infinity, Infinity, Infinity, 0, 1, 0, 0, 1, 2, 3, 4, 0]</code> 값이 된다. <code class="language-plaintext highlighter-rouge">Infinity</code>로 초기화한 이유는 해당 문자 왼쪽엔 <code class="language-plaintext highlighter-rouge">c</code>가 있는지 알 수 없기 때문이다.</li>
  <li>두번째로 이번엔 오른쪽에서 왼쪽으로 이동하면서 <code class="language-plaintext highlighter-rouge">c</code>와의 거리를 구하기 위해 <code class="language-plaintext highlighter-rouge">for</code>문을 사용한다. 즉, 오른쪽에서 왼쪽을 순회하면서 <code class="language-plaintext highlighter-rouge">c</code>와의 거리는 <code class="language-plaintext highlighter-rouge">[3, 2, 1, 0, 1, 0, 0, 4, 3, 2, 1, 0]</code> 값이 된다.</li>
  <li>for문의 마지막 <code class="language-plaintext highlighter-rouge">result[i]</code>에 삽입할 때, 왼쪽에서 오른쪽으로 진행한 기존의 <code class="language-plaintext highlighter-rouge">result</code>값인 <code class="language-plaintext highlighter-rouge">[Infinity, Infinity, Infinity, 0, 1, 0, 0, 1, 2, 3, 4, 0]</code>과 오른쪽에서 왼쪽으로 진행한 <code class="language-plaintext highlighter-rouge">[3, 2, 1, 0, 1, 0, 0, 4, 3, 2, 1, 0]</code>값을 비교해서, 작은 수를 배열에 삽입하면 된다.</li>
</ol>
:ET