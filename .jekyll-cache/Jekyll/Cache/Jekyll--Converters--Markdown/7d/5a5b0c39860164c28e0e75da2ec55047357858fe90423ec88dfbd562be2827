I" <p><a href="https://leetcode.com/problems/largest-substring-between-two-equal-characters/">문제</a></p>

<h2 id="접근하기">접근하기</h2>

<p>문자열 <code class="language-plaintext highlighter-rouge">s</code>가 주어진다. <code class="language-plaintext highlighter-rouge">s</code>내부 문자열들 중 중복되는 알파벳이 있다면, 그 사이의 알파벳의 개수를 반환하고, 중복되는 문자열이 없다면 -1을 반환한다.</p>

<p><br /></p>

<h2 id="내-코드">내 코드</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">maxLengthBetweenEqualCharacters</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="nx">answer</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">i</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">answer</span><span class="p">)</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">?</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">answer</span><span class="p">)</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<ol>
  <li>2중for문을 사용해서, <code class="language-plaintext highlighter-rouge">i</code>와 <code class="language-plaintext highlighter-rouge">j</code>가 같으면, 그 사이의 알파벳 개수를 구해 배열에 담아 가장 큰 값을 반환하고, 아니면 -1을 반환한다.</li>
</ol>

<h2 id="참고-코드">참고 코드</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">maxLengthBetweenEqualCharacters</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">lastIdx</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">lastIndexOf</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">lastIdx</span> <span class="o">!==</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">result</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">lastIdx</span> <span class="o">-</span> <span class="nx">i</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<ol>
  <li>2중배열을 사용하면 130ms정도의 시간이 나오는데, 위 방법을 사용할 때 80ms가 나와서 코드를 살펴보았다.</li>
  <li>재밌는 점은 <code class="language-plaintext highlighter-rouge">lastIndexOf()</code>를 사용했다는 점이다. <code class="language-plaintext highlighter-rouge">lastIndexOf()</code>는 <code class="language-plaintext highlighter-rouge">indexOf()</code>와 마찬가지로 인자로 받는 값의 인덱스를 반환한다. 기존 <code class="language-plaintext highlighter-rouge">indexOf()</code>와 차이점은 <code class="language-plaintext highlighter-rouge">lastIndexOf()</code>는 기준을 뒤부터 잡는다는 점이다. 그렇다고 <strong>맨 앞에 있는 인덱스 번호를 맨 뒤를 0으로 하여 세는 것이 아닌 검색만 뒤에서부터 할 뿐 인덱스 번호는 <code class="language-plaintext highlighter-rouge">indexOf()</code>와 동일</strong>하다.</li>
  <li>예를 들어서 <code class="language-plaintext highlighter-rouge">ojdncpvyneq</code>이런 문자열이 있다고 하자. 중복되는 문자는 <code class="language-plaintext highlighter-rouge">n</code>이며 이를 <code class="language-plaintext highlighter-rouge">lastIndexOf()</code>를 했을 때 어떻게 반환하는지 보자.</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">lastIdx</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">lastIndexOf</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="c1">// 기존 인덱스 :    0 1 2 3 4 5 6 7 8 9 10</span>
<span class="c1">// lastIndexOf : 0 1 2 8 4 5 6 7 8 9 10</span>
</code></pre></div></div>

<ol>
  <li>검색 우선순위만 뒤에서 할 뿐이지 인덱스번호도 거꾸로 되는 것은 아니다. 즉, n은 앞에선 3이지만 뒤에 기준을 두었을 땐 뒤부터 검색하므로 인덱스 번호 8이 된다.</li>
  <li>다음 로직에서 <code class="language-plaintext highlighter-rouge">if (lastIdx !== i)</code>경우, 즉 기존 인덱스 3과 <code class="language-plaintext highlighter-rouge">lastOfIndex()</code>로 검색한 8일 때 두 수의 차이를 구하여 중복된 알파벳 사이의 개수를 구하는 것이다.</li>
</ol>
:ET