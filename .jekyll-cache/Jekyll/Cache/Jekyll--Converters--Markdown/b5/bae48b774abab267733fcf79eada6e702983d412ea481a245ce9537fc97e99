I"%<p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">문제</a></p>

<h2 id="문제-설명">문제 설명</h2>

<p>이진 트리의 <code class="language-plaintext highlighter-rouge">root</code>가 주어지면, 노드의 값들을 중위 순회로 반환하라.</p>

<p><strong>예시 1</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [1,null,2,3]
Output: [1,3,2]
</code></pre></div></div>

<p><strong>예시 2</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = []
Output: []
</code></pre></div></div>

<p><strong>예시 3</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [1]
Output: [1]
</code></pre></div></div>

<p><strong>예시 4</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [1,2]
Output: [2,1]
</code></pre></div></div>

<p><strong>예시 5</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [1,null,2]
Output: [1,2]
</code></pre></div></div>

<p><strong>제한사항</strong></p>

<ul>
  <li>트리의 노드 수는 [0, 100]범위안에 있다.</li>
  <li>100 &lt;= Node.val &lt;= 100</li>
</ul>

<p><br /></p>

<h2 id="해결방법">해결방법</h2>

<p><strong>접근하기</strong></p>

<p>이진 트리의 중위 순회를 하기 위해선 대표적으로 재귀 호출하는 방법과 스택을 이용한 반복이 있다. 두 방법을 이용해서 구현해보자.</p>

<p><strong>알고리즘</strong></p>

<ol>
  <li>첫 번째 방법은 재귀를 이용한 방법이다.</li>
  <li><code class="language-plaintext highlighter-rouge">inorderTraversal(root)</code>함수 내부로 들어가보자. 결과를 담는 <code class="language-plaintext highlighter-rouge">result</code>배열과 <code class="language-plaintext highlighter-rouge">traverse(node)</code>라는 순회를 위한 중첩함수를 호출하고 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">traverse(node)</code>가 순회하기 위한 핵심로직이며, 재귀를 이루는 부분이다. 먼저 처음 <code class="language-plaintext highlighter-rouge">traverse(root)</code>를 호출하면 <code class="language-plaintext highlighter-rouge">traverse(1)</code>로 호출이 되며, 저 <code class="language-plaintext highlighter-rouge">1</code>은 일반적인 숫자가 아닌, LeetCode에서 미리 정의된 생성자 함수 <code class="language-plaintext highlighter-rouge">TreeNode</code>의 객체이다. 즉, <code class="language-plaintext highlighter-rouge">1</code>은 프로퍼티로 <code class="language-plaintext highlighter-rouge">val</code>, <code class="language-plaintext highlighter-rouge">left</code>, <code class="language-plaintext highlighter-rouge">right</code>를 가지고 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">traverse(root)</code>를 호출하게 되면, <code class="language-plaintext highlighter-rouge">traverse()</code>함수 내부로 들어가게 된다. 여기서 결과에 푸쉬하는 코드가 어디에 위치하는지 순서가 중요하다.</li>
  <li>중위 순회는 루트가 중앙에 위치하게 된다. 즉, 왼쪽 - <strong>루트</strong> - 오른쪽 순서를 기억하자.</li>
  <li><code class="language-plaintext highlighter-rouge">traverse(node.left)</code>로 먼저 왼쪽 노드가 <code class="language-plaintext highlighter-rouge">null</code>일 때 까지 호출한다.</li>
  <li>더이상 왼쪽 노드가 없어 <code class="language-plaintext highlighter-rouge">null</code>을 만나게 되면 스택프레임에 쌓여있던 왼쪽 노드들이 호출이 되며 <code class="language-plaintext highlighter-rouge">result</code>에 <code class="language-plaintext highlighter-rouge">push</code>가 된다.</li>
  <li>왼쪽 노드의 <code class="language-plaintext highlighter-rouge">push</code>가 끝나면 이제 <code class="language-plaintext highlighter-rouge">root</code>를 <code class="language-plaintext highlighter-rouge">push</code>하게 되고 다음 오른쪽 노드를 탐색하게 되서 위 절차와 동일한 방법으로 순회하게 된다. 결국, 루트가 중앙으로 오게 되는 중위 순회가 이루어진다.</li>
</ol>

<hr />

<ol>
  <li>다음은 스택방식이다. 스택도 재귀와 매우 유사하다.</li>
  <li><code class="language-plaintext highlighter-rouge">while</code>문 내부의 <code class="language-plaintext highlighter-rouge">while</code>문을 보면, <code class="language-plaintext highlighter-rouge">curr</code>은 <code class="language-plaintext highlighter-rouge">root</code>를 가리키며, 최초 스택에 1을 넣는다. 다음 <code class="language-plaintext highlighter-rouge">left</code>를 먼저 방문하며 <code class="language-plaintext highlighter-rouge">null</code>이 나올 때 까지 반복하고, <code class="language-plaintext highlighter-rouge">null</code>이 나오면 스택에서 <code class="language-plaintext highlighter-rouge">pop()</code>한 후 해당 값을 <code class="language-plaintext highlighter-rouge">result</code>에 담는다.</li>
  <li>그 다음 <code class="language-plaintext highlighter-rouge">root</code>를 결과에 담고 이제 오른쪽을 순회한다.</li>
</ol>

<p><br /></p>

<h2 id="풀이코드">풀이코드</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Recursive</span>

<span class="kd">const</span> <span class="nx">inorderTraversal</span> <span class="o">=</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="nx">traverse</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="nx">traverse</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">);</span>
    <span class="nx">traverse</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Stack</span>

<span class="kd">const</span> <span class="nx">inorderTraversal</span> <span class="o">=</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">curr</span> <span class="o">=</span> <span class="nx">root</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">let</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">curr</span> <span class="o">||</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">curr</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">curr</span><span class="p">);</span>
      <span class="nx">curr</span> <span class="o">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">curr</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">val</span><span class="p">);</span>
    <span class="nx">curr</span> <span class="o">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><strong>복잡도</strong></p>

<ul>
  <li>시간 복잡도: 재귀와 스택 둘 다 배열을 한 번만 순회하므로 <code class="language-plaintext highlighter-rouge">O(N)</code>을 갖는다.</li>
</ul>
:ET