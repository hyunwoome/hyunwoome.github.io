I"<p><a href="https://leetcode.com/problems/valid-mountain-array/">문제</a></p>

<h2 id="문제-설명">문제 설명</h2>

<p>정수형 배열 <code class="language-plaintext highlighter-rouge">arr</code>가 주어지며, 만약 <strong>유효한 산(valid mountain) 배열</strong>인 경우에만 <code class="language-plaintext highlighter-rouge">true</code>를 반환한다.</p>

<p>다음과 같은 경우가 <strong>유효한 산(valid mountain) 배열</strong>이다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">arr.length &gt;= 3</code></li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">i</code>는 <code class="language-plaintext highlighter-rouge">0 &lt; i &lt; arr.length - 1</code>여야 하며,</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>
      <li><code class="language-plaintext highlighter-rouge">arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/76833697/123541089-76443f00-d77d-11eb-8261-4cc234fa8528.png" alt="hint_valid_mountain_array" /></p>

<p><strong>예시 1</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>입력: arr = [2, 1]
출력: false
</code></pre></div></div>

<p><strong>예시 2</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>입력: arr = [3, 5, 5]
출력: false
</code></pre></div></div>

<p><strong>예시 3</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>입력: arr = [0, 3, 2, 1]
출력: true
</code></pre></div></div>

<p><strong>제한사항</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= arr.length &lt;= 104</code></li>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= arr[i] &lt;= 104</code></li>
</ul>

<p><br /></p>

<h2 id="해결방법">해결방법</h2>

<p><strong>접근하기</strong></p>

<p>문제가 요구하는 조건을 잘 생각해보자.
일단 <strong>배열의 크기는 무조건 3 이상</strong>이여야 <code class="language-plaintext highlighter-rouge">true</code>를 반환할 수 있다.
또 유효한 산 배열이 되려면 <code class="language-plaintext highlighter-rouge">i</code>는 <code class="language-plaintext highlighter-rouge">i + 1</code>보다 무조건 커야하는 조건과, <code class="language-plaintext highlighter-rouge">i</code>는 <code class="language-plaintext highlighter-rouge">i + 1</code>보다 무조건 작아야 하는 조건을 만족해야 한다. 즉 <code class="language-plaintext highlighter-rouge">i</code>가 <code class="language-plaintext highlighter-rouge">i + 1</code>과 같아버리면 위 조건은 성립될 수 없다.</p>

<p>그렇다면 <code class="language-plaintext highlighter-rouge">i &lt; i + 1</code>이 만족하는 경우를 세고, <code class="language-plaintext highlighter-rouge">i &gt; i + 1</code>가 만족하는 경우를 세서 <strong>두 값을 합친 값이 배열의 원소 갯수와 일치</strong>하면 그 배열은 유효한 산 배열이라고 볼 수 있을 것이다.</p>

<p><strong>알고리즘</strong></p>

<ol>
  <li>배열을 두 번 순회하는데, 한 번은 <code class="language-plaintext highlighter-rouge">i &lt; i + 1</code>조건을 만족하는 경우를 센다.</li>
  <li>두 번째는 <code class="language-plaintext highlighter-rouge">i &gt; i + 1</code> 조건을 만족하는 경우를 센다.</li>
  <li>두 값을 더해 배열의 원소 갯수와 일치하는지 확인하는 것이다.</li>
</ol>

<p><br /></p>

<h2 id="풀이코드">풀이코드</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">validMountainArray</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">N</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// arr[i + 1]이 arr[i]보다 클 경우 카운팅</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">N</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 배열의 원소가 오름차순이거나 내림차순일 때 바로 false 반환</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">i</span> <span class="o">===</span> <span class="nx">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>

  <span class="c1">// arr[i + 1]이 arr[i]보다 작을 경우 카운팅</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">N</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">i</span> <span class="o">===</span> <span class="nx">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><strong>복잡도</strong></p>

<ul>
  <li>시간 복잡도: 한 배열을 두 번 순회해야 하므로 <code class="language-plaintext highlighter-rouge">O(2N)</code>이면 될 것 같다.</li>
</ul>
:ET