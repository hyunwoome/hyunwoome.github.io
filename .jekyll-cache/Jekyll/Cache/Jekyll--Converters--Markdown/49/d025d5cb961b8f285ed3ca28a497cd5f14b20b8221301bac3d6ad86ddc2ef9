I"K<blockquote>
  <p>이 포스팅은 이웅모님의 <a href="https://wikibook.co.kr/mjs/">JavaScript Deep Dive</a>를 읽고 정리한 내용입니다.</p>
</blockquote>

<p><br /></p>

<h2 id="1-연산자">1. 연산자</h2>

<ul>
  <li>연산자(operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산등을 수행해 하나의 값을 만든다.</li>
</ul>

<p><br /></p>

<h2 id="2-산술-연산자">2. 산술 연산자</h2>

<ul>
  <li>산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산이 불가능한 경우, <code class="language-plaintext highlighter-rouge">NaN</code>을 반환한다.</li>
</ul>

<h3 id="이항-산술-연산자">이항 산술 연산자</h3>

<ul>
  <li>
    <p>2개의 피연산자를 산술 연산하여 숫자 값을 만들며, 피연산자의 값을 변경하는 부수효과가 없다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">+</code> : 덧셈</li>
  <li><code class="language-plaintext highlighter-rouge">-</code> : 뺄셈</li>
  <li><code class="language-plaintext highlighter-rouge">*</code> : 곱셈</li>
  <li><code class="language-plaintext highlighter-rouge">/</code> : 나눗셈</li>
  <li><code class="language-plaintext highlighter-rouge">%</code> : 나머지</li>
</ul>

<h3 id="단항-산술-연산자">단항 산술 연산자</h3>

<ul>
  <li>
    <p>1개의 피연산자를 산술 연산하여 숫자 값을 만든다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">++</code> : 증가 (부수효과발생)</li>
  <li><code class="language-plaintext highlighter-rouge">--</code> : 감소 (부수효과발생)</li>
  <li><code class="language-plaintext highlighter-rouge">+</code> : 아무효과없음</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">-</code> : 양수를 음수로, 음수를 양수로 반전</p>
  </li>
  <li>
    <p>증가 감소 연산자는 위치에 의미가 있다.</p>

    <ul>
      <li>
        <p>피연산자 앞에 위치한 <strong>전위 증가 / 감소</strong> 연산자는 먼저 피연산자의 값을
증가 / 감소시킨 후 다른연산을 수행</p>
      </li>
      <li>
        <p>피연산자 뒤에 위치한 <strong>후위 증가 / 감소</strong> 연산자는 먼저 다른 연산을 수행한 수 피연산자의 값을 증가 / 감소 시킴</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="문자열-연결-연산자">문자열 연결 연산자</h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">+</code>연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.</strong></li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 문자열 연결 연산자</span>
<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// '12'</span>
<span class="mi">1</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// '12'</span>

<span class="c1">// 암묵적 타입 변환</span>
<span class="mi">1</span> <span class="o">+</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// 2</span>
<span class="mi">1</span> <span class="o">+</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// 1</span>
</code></pre></div></div>

<ul>
  <li>산술연산자를 사용할 때 다른 타입의 피연산자를 연산할 시 암묵적으로 타입이 변경되니 주의해야 한다.</li>
</ul>

<p><br /></p>

<h2 id="3-할당-연산자">3. 할당 연산자</h2>

<ul>
  <li>
    <p>할당 연산자(assignment operator)는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">=</code> : <code class="language-plaintext highlighter-rouge">x = 5</code> (부수효과발생)</li>
  <li><code class="language-plaintext highlighter-rouge">+=</code> : <code class="language-plaintext highlighter-rouge">x += 5</code> (부수효과발생)</li>
  <li><code class="language-plaintext highlighter-rouge">-=</code> : <code class="language-plaintext highlighter-rouge">x -= 5</code> (부수효과발생)</li>
  <li><code class="language-plaintext highlighter-rouge">*=</code> : <code class="language-plaintext highlighter-rouge">x *= 5</code> (부수효과발생)</li>
  <li><code class="language-plaintext highlighter-rouge">/=</code> : <code class="language-plaintext highlighter-rouge">x /= 5</code> (부수효과발생)</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">%=</code> : <code class="language-plaintext highlighter-rouge">x %= 5</code> (부수효과발생)</p>
  </li>
  <li><strong>할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.</strong></li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span><span class="p">;</span>
<span class="c1">// 할당문은 표현식인 문이다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">((</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">));</span> <span class="c1">// 10</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="4-비교-연산자">4. 비교 연산자</h2>

<ul>
  <li>비교 연산자(comparison operator)는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 <strong>불리언</strong> 값으로 반환한다.</li>
</ul>

<h3 id="동등--일치-비교-연산자">동등 / 일치 비교 연산자</h3>

<ul>
  <li>
    <p>동등 비교 연산자와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환한다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">==</code> : 동등 비교 (x와 y의 값이 같음)</li>
  <li><code class="language-plaintext highlighter-rouge">===</code> : 일치 비교 (x와 y의 값과 타입이 같음)</li>
  <li><code class="language-plaintext highlighter-rouge">!=</code> : 부동등 비교 (x와 y의 값이 다름)</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">!==</code> : 불일치 비교 (x와 y의 값과 타입이 다름)</p>
  </li>
  <li>동등 비교는 비교할 때 먼저 <strong>암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교</strong>하기 때문에 예측하기 어려워 <strong>일치 비교 연산자</strong>를 사용한다.</li>
</ul>

<h3 id="대소-관계-비교-연산자">대소 관계 비교 연산자</h3>

<ul>
  <li>
    <p>피연산자의 크기를 비교하여 <strong>불리언 값</strong>을 반환한다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">x &gt; y</code> : x가 y보다 크다</li>
  <li><code class="language-plaintext highlighter-rouge">x &lt; y</code> : x가 y보다 작다</li>
  <li><code class="language-plaintext highlighter-rouge">x &gt;= y</code> : x가 y보다 크거나 같다</li>
  <li><code class="language-plaintext highlighter-rouge">x &lt;= y</code> : x가 y보다 작거나 같다</li>
</ul>

<p><br /></p>

<h2 id="5-삼항-조건-연산자">5. 삼항 조건 연산자</h2>

<ul>
  <li>삼항 조건 연산자(ternary operator)는 조건식의 평가 결과에 따라 반환할 값을 결정한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 조건식 ? true일 때 : false일 때</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="mi">100</span>
<span class="nx">result</span> <span class="o">=</span> <span class="nx">result</span> <span class="o">&gt;=</span> <span class="mi">60</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">pass</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">fail</span><span class="dl">'</span><span class="p">;</span>
<span class="c1">// result는 100이 할당되어 있고, 60보다 크거나 같은경우엔 pass, 아니면 fail을 반환</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="6-논리-연산자">6. 논리 연산자</h2>

<ul>
  <li>
    <p>논리 연산자(logical operator)는 우항과 좌항의 피연산자를 논리 연산한다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">||</code> : 논리합(OR)</li>
  <li><code class="language-plaintext highlighter-rouge">&amp;&amp;</code> : 논리곱(AND)</li>
  <li><code class="language-plaintext highlighter-rouge">!</code> : 부정(NOT)</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 논리합(||) 연산자</span>
<span class="kc">true</span> <span class="o">||</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// true</span>
<span class="kc">true</span> <span class="o">||</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// true</span>
<span class="kc">false</span> <span class="o">||</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// true</span>
<span class="kc">false</span> <span class="o">||</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// false</span>

<span class="c1">// 논리곱(&amp;&amp;) 연산자</span>
<span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// true</span>
<span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// false</span>
<span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// false</span>
<span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// false</span>

<span class="c1">// 논리 부정(!) 연산자</span>
<span class="o">!</span><span class="kc">true</span><span class="p">;</span> <span class="c1">// false</span>
<span class="o">!</span><span class="kc">false</span><span class="p">;</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="7-쉼표-연산자">7. 쉼표 연산자</h2>

<ul>
  <li>쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">;</span>
<span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="nx">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 3</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="8-그룹-연산자">8. 그룹 연산자</h2>

<ul>
  <li>소괄호(‘( )’)로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다. 그룹 연산자를 사용하면 연산자의 우선순위를 조절할 수 있다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">10</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// 23</span>
<span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 50</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="9-typeof-연산자">9. typeof 연산자</h2>

<ul>
  <li>typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.</li>
  <li>typeof 연산자가 반환하는 문자열은 <strong>7개의 데이터 타입과 정확히 일치하지는 않는다.</strong></li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typeof</span> <span class="dl">''</span><span class="p">;</span> <span class="c1">// 'string'</span>
<span class="k">typeof</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 'number'</span>
<span class="k">typeof</span> <span class="kc">NaN</span><span class="p">;</span> <span class="c1">// 'number'</span>
<span class="k">typeof</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// 'boolean'</span>
<span class="k">typeof</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// 'undefined'</span>
<span class="k">typeof</span> <span class="nb">Symbol</span><span class="p">();</span> <span class="c1">// 'symbol</span>
<span class="k">typeof</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 'object'</span>
<span class="k">typeof</span> <span class="p">[];</span> <span class="c1">// 'object'</span>
<span class="k">typeof</span> <span class="p">{};</span> <span class="c1">// 'object'</span>
<span class="k">typeof</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span> <span class="c1">// 'object</span>
<span class="k">typeof</span> <span class="sr">/test/gi</span><span class="p">;</span> <span class="c1">// 'object'</span>
<span class="k">typeof</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span> <span class="c1">// 'function</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">null</code>의 타입이 <code class="language-plaintext highlighter-rouge">object</code>인 것에 주의한다. (버그)</li>
  <li><code class="language-plaintext highlighter-rouge">null</code>타입을 확인할 땐 일치 연산자(<code class="language-plaintext highlighter-rouge">===</code>)를 사용한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="k">typeof</span> <span class="nx">foo</span> <span class="o">===</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// false</span>
<span class="nx">foo</span> <span class="o">===</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// true</span>
</code></pre></div></div>

<ul>
  <li>식별할 수 없는 식별자를 연산하면 오류가 아닌 <code class="language-plaintext highlighter-rouge">undefined</code>가 반환된다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typeof</span> <span class="nx">undeclared</span><span class="p">;</span> <span class="c1">// undefined</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="10-지수-연산자">10. 지수 연산자</h2>

<ul>
  <li>ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑(base)으로, 우항의 피연산자를 지수(exponent)로 거듭제곱하여 숫자 값을 반환한다.</li>
  <li>ES7전에는 <code class="language-plaintext highlighter-rouge">Math.pow()</code>메서드를 사용했다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="mi">2</span> <span class="o">**</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 1</span>
<span class="mi">2</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="c1">// 0.25</span>

<span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// 4</span>
<span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 0.25</span>
</code></pre></div></div>

<ul>
  <li><strong>음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어야 한다.</strong></li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span><span class="mi">5</span> <span class="o">**</span> <span class="mi">2</span> <span class="c1">// SyntaxError: ...</span>
<span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 25</span>
</code></pre></div></div>

<ul>
  <li>지수 연산자는 이항 연산자 중 우선순위가 가장 높다</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 50</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="11-그-외-연산자">11. 그 외 연산자</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">?</code> : 옵셔널 체이닝 연산자</li>
  <li><code class="language-plaintext highlighter-rouge">??</code> : null 병합 연산자</li>
  <li><code class="language-plaintext highlighter-rouge">delete</code> : 프로퍼티 삭제</li>
  <li><code class="language-plaintext highlighter-rouge">new</code> : 생성자 함수를 호출할 때 사용하여 인스턴스 생성</li>
  <li><code class="language-plaintext highlighter-rouge">instanceof</code> : 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별</li>
  <li><code class="language-plaintext highlighter-rouge">in</code> : 프로터티 존재 확인</li>
</ul>
:ET